=== Guardar canvis al respositori

Tenim un repositori Git creat i una còpia de treball o “checkout” dels fitxers d'aquest projecte. 
Cada cop que hàgim fet canvis al projecte i aquest hagi arribat a un estat que ens interessi conservar, farem un “commit” i així confirmarem que volem guardar les instantànies dels nous canvis al nostre repositori.

Recordem que cada fitxer al nostre directori de treball només pot tenir dos estats: amb seguiment (tracked) o sense seguiment (untracked). 
Els arxius “amb seguiment” són aquells que es troben en l'última instantània del canvi; poden ser modificats, no modificats o preparats (staged). 
En canvi, els arxiu “sense seguiment” són tota la resta, és a dir, qualsevol arxiu que no formi part de l'últim canvi o no hi sigui a l'àrea de de preparació (staging area). 
Quan clonem per primer cop un repositori, tots els nostres fitxers seran a l'estat “amb seguiment” i “no modificats” ja que Git acaba de fer-ne una còpia i encara no hem modificat res.

A mesura que anem editat més fitxers, Git els veurà com a modificats perquè han patit quelcom canvi des de l'última confirmació (commit). 
El següent pas serà preparar aquests arxius modificats i confirmar els canvis, repetirem aquest cicle cada vegada que ens interessi guardar una modificació.

.Cicle de vida de l'estat dels nostres fitxers.
image::images/lifecycle.png[The lifecycle of the status of your files.]

[[_checking_status]]
==== Comprovar l'estat dels nostres fitxers

Per poder determinar l'estat on s'hi troben els nostres arxius podem executar l'ordre `git status`.(((git commands, status)))
Si l'executem després d'haver clonat un repositori veurem el següent:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working directory clean
----

Això significa que tenim un directori de treball net, o dit d'una altra manera, que cap dels arxius amb l'estat “amb seguiment” han estat modificats.
A més a més Git tampoc troba cap dels fitxers amb l'estat “sense seguiment”, ja que tampoc estan llistats. 
Finalment, al resultat de l'execució podem observar a quina branca ens trobem i ens informa que no existeix cap divergència procedent de la mateixa branca al servidor. 
Per ara, considerarem aquesta, la branca ``master'', que és diu així per ser la branca per defect.
Més endavant, a <<_git_branching>> explicarem amb més profunditat tot el que cal que sapiguem sobre les branques a Git.

Suposem que afegim un nou arxiu al nostre projecte, per exemple un simple fitxer de lectura README. 
Si és el primer cop que s'ha creat l'arxiu i executem un altre cop `git status` podrem veure el nostre arxiu “sense seguiment” així:

[source,console]
----
$ echo 'My Project' > README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Untracked files:
  (use "git add <file>..." to include in what will be committed)

    README

nothing added to commit but untracked files present (use "git add" to track)
----

Podem observar que el nostre nou fitxer README és a l'estat "sense seguiment" com indica  a la capçalera del resultat. 
"Sense seguiment" només significa que Git ha trobat un fitxer que no havia sigut confirmat amb anterioritat, o el que és el mateix, un fitxer al que no havíem fet cap ``commit'' encara. 
Per tant Git no l'inclourà als nostres arxius confirmats fins que no ho hàgim indicat nosaltres.
Funciona així per evitar incloure fitxers que no vulguem o que hagin estat generats automàticament. D'altra banda, com si que ens interessa incloure el nou fitxer README, començarem per fer-li un seguiment.

[[_tracking_files]]
==== Seguiment de nous fitxers

Per poder començar amb el seguiment d'un nou fitxer, farem servir l'ordre `git add`.(((git commands, add)))
Per seguir el fitxer README que havíem creat, executarem:

[source,console]
----
$ git add README
----

Si executem una vegada més l'ordre per comprovar a quin estat es troba, podrem veure com el nostre fitxer README ha passat a estar “amb seguiment” i preparat per ser confirmat:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README

----

Podem saber que es troba preparat perquè està llistat a l'apartat "Canvis per confirmar" ("Changes to be committed"). 
Si decidim confirmar en aquest punt, els canvis que romandran guardats són els que hàgim fet abans d'executar `git add`.
Recordem que quan abans varem executar `git init`, i a continuació `git add (fitxer)` ho vam fer per poder fer un seguiment dels fitxers del nostre directori.(((git commands, init)))(((git commands, add)))
L'ordre `git add` agafa la ruta del fitxer o del directori, en cas que sigui un directori, l'execució de l'ordre afegirà de forma recursiva tots els fitxers a dintre d'aquest mateix directori.

==== Preparació de fitxers modificats

Anem a modificar un arxiu "amb seguiment". 
Si per exemple fem canvis a l'arxiu `CONTRIBUTING.md` que ja es trobava amb l'estat "amb seguiment" i executem la comanda `git status`, obtindrem:(((git commands, status))) 

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

----

El nostre fitxer `CONTRIBUTING.md` apareix a la secció "Canvis no preparats per a confirmació" ("Changes not staged for commit"), que ve a dir que un arxiu "amb seguiment" s'ha modificat al directori de treball però encara no està preparat.
Per tal de preparar-lo executarem l'ordre `git add` que serveix tant per a posar en seguiment nous fitxers, com per a preparar-los o altres utilitats com marcar com resolts arxius amb conflictes d'unió. 
Ens pot ajudar a entendre `git add` pensar que serveix més per a "afegir el nou contingut per a nova confirmació"" que per a "afegir el fitxer al projecte".(((git commands, add)))
Executem ara `git add` per a preparar l'arxiu `CONTRIBUTING.md`  i després `git status`:(((git commands, status)))

[source,console]
----
$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

----

Ambdós fitxers estan preparats i hi seran a la propera confirmació. 
Suposem, que en aquests moments, recordem que necessitem fer una petita modificació a `CONTRIBUTING.md` abans de confirmar.
En aquesta situació, simplement l'haurem d'obrir i fer els canvis adients, un cop fet ja podem confirmar.
Tot i així, executem un cop més `git status`: 

[source,console]
----
$ vim CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

----

Què ha passat?
Ara `CONTRIBUTING.md` està inclòs tant a la llista d'arxius preparats com a la llista dels no preparats.
Com pot ser?
El que ha passat és que Git prepara un fitxer exactament com es troba després d'executar l'ordre `git add`.
Si confirmem executant `git commit`, la versió a la que s'aplicarà la confirmació serà l'última abans de l'ordre `git add` i no l'última versió guardada el nostre directori de treball.
En conclusió, si modifiquem qualsevol fitxer després d'haver executat `git add`, ho haurem d'executar un altre cop si volem que la versió de l´últim canvi hi formi part dels fitxer preparats:

[source,console]
----
$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md
----

==== Acurtament de l'estat

Encara que el resultat de `git status` es força fàcil d'entendre, és cert que pot resultar-nos massa extens.
Per sort, Git ens dóna la possibilitat d'obtenir un resultat més resumit si executem `git status -s` o `git status --short`:


[source,console]
----
$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
----

Els nous arxius que no es troben "amb seguiment" tindran `??` al seu costat, els fitxers que s'han afegit a l'àrea de preparació tindran una `A`, els modificats una `M`, etc.
Al resultat hi ha dues columnes, la de l'esquerra ens indica l'estat  de l'àrea de preparació i la de la dreta l'estat de l'arbre de treball.
Al nostre exemple, veiem que hem modificat el fitxer `README` al nostre directori de treball però encara no l'hem preparat.
Mentre que l'arxiu `lib/simplegit.rb` està modificat i preparat.
L'arxiu `Rakefile` el vam modificar, preparat i modificat per segon cop, per tant hi ha canvis que es troben en l'àrea de preparació i no-preparació a la vegada.

[[_ignoring]]
==== Ignorar Fitxers

Sovint, ens trobem amb fitxers que no volem que Git els afegeixi automàticament o inclús que apareguin com “sense seguiment”.
Generalment són fitxers que es creen automàticament com els “log”, o generats pel nostre compilador.
En aquests casos, podem crear un arxiu anomenat `.gitignore`, on llistem patrons de noms que volem que siguin ignorats.(((ignoring files)))
Un exemple d'un fitxer `.gitignore`:

[source,console]
----
$ cat .gitignore
*.[oa]
*~
----

La primer línia li indica a Git que ignori qualsevol fitxer acabat en ``.o'' o ``.a'', corresponents a objectes o fitxers que solen ser producte de compilar el nostre codi.
La segona línia li diu a Git que ignori tots els fitxers on el seu nom acabi amb (`~`), format utilitzat per molt editors de text com Emacs per marcar els fitxers temporals.
També podríem incloure “log”, “tmp” o directoris “pid”; documentació generada automàticament, etc.
Configurar fitxers `.gitignore` abans de continuar amb el desenvolupament és recomanable per tal d'evitar confirmar fitxers accidentalment i apareguin al nostre repositori Git.

Hem de seguir certes regles per poder crear patrons als fitxers `.gitignore`:

*  Línies en blanc o que comencin per `#` són ignorades.
*  Podem fer servir patrons glob estàndard.
*  Per evitar recursivitat podem començar patrons per la barra inclinada (`/`).
*  Per especificar un directori podem acabar el patró amb la barra inclinada (`/`).
*  Podem negar un patró si el comencem amb un signe d'exclamació (`!`).

Els patrons Glob són expressions regulars simplificades utilitzades per les consoles.
Un asterisc (`*`) significa zero o més caràcters; `[abc]` vol dir qualsevol caràcter a dins dels claudàtors (a, b, o c, en aquest cas); un signe interrogatiu (`?`) substitueix un sol caràcter;  caràcters a dins de claudàtors i separats per un guió (`[0-9]`) indica qualsevol caràcter entre ells dos (en aquest cas de 0 a 9).
També podem fer servir dos asteriscs per indicar directoris niats, per exemple, `a/**/z` afectarà a  `a/z`, `a/b/z`, `a/b/c/z`, etc.

Aquí podem veure un exemple més clar d'arxius `.gitignore`:

[source]
----
# cap arxiu .a
*.a

# incloem l'arxiu lib.a encara que ignorem tots els que siguin .a com hem dit a dalt
!lib.a

# només ignorem el fitxer TODO al directori actual, no al subdirectori/TODO
/TODO

# ignorem tots els fitxers al directori build/
build/

# ignorem doc/notes.txt, però no doc/server/arch.txt
doc/*.txt

# ignorem tots els fitxers .pdf al directori doc/
doc/**/*.pdf
----

[TIP]
====
 GitHub manté una llista bastant completa de bons exemples de fitxers `.gitignore`.
 Podem consultar aquests exemples inclosos a dotzenes de projectes i llenguatges a  https://github.com/github/gitignore[].
 Així ens podem basar en un exemple pràctic abans de començar el nostre propi projecte.
====

[[_git_diff_staged]]
==== Veure canvis preparats i no preparats

Si la comanda `git status` és massa vaga per a nosaltres, i volem saber exactament els canvis que hem fet enlloc de només els fitxers afectats, podem fer servir l'ordre `git diff`.(((git commands, diff)))
Parlarem de `git diff` en profunditat més endavant, però probablement el farem servir més freqüentment per respondre aquestes dues preguntes: Què hem canviat però encara no està preparat?
I què hem preparat però resta confirmar?
Encara que `git status` respon de manera general llistant el nom dels fitxers afectats `git diff` ens mostra exactament les línies afegides o eliminades.

Diguem que modifiquem i preparem el fitxer `README` un altre cop i després editem l'altre fitxer `CONTRIBUTING.md` sense preparar-lo.
Si executem la comanda `git status`, tornarem a veure alguna cosa semblant a això:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    modified:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

Per veure el què hem modificat però encara no hem prepara't, escrivim `git diff` sense cap altre argument:
[source,console]
----
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
----

Aquesta ordre compara el que hi ha al nostre directori de treball amb el que hi ha a l'àrea de preparació.
El resultat ens mostra els canvis que hem fet però no hem preparat encara.

Si volem veure el que hem preparat per a que quedi inclòs a la següent confirmació, podem fer servir `git diff --staged`.
Aquesta ordre compara els canvis en preparació amb l'última confirmació:

[source,console]
----
$ git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project
----

És important saber que `git diff` per ell mateix no ens mostra els canvis fets des de l'última confirmació, únicament ens mostrarà els canvis sense praparar.
Això pot semblar confús perquè si hem prepara't totes les nostres modificacions, `git diff` no ens mostrarà cap resultat.


Per exemple, si preparem el fitxer `CONTRIBUTING.md` i després l'editem, podem fer servir `git diff` per veure els canvis al fitxer que estiguin preparats i no preparats:

[source,console]
----
$ git add CONTRIBUTING.md
$ echo '# test line' >> CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

Ara podem fer servir `git diff` per a veure els que encara no estan preparats:

[source,console]
----
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 643e24f..87f08c8 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -119,3 +119,4 @@ at the
 ## Starter Projects

 See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+# test line
----

i `git diff --cached` per veure que hem preparat fins ara(`--staged` and `--cached` són sinònims): 

[source,console]
----
$ git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
----

[NOTA]
.Git Diff a una ferramenta externa
====
Continuarem usant l'ordre `git diff` de diferents maneres durant la resta del llibre.
Si ho preferim, podem veure les diferències (diffs) d'una manera més gràfica o amb una vista d'un programa extern.
Si executem `git difftool` enlloc de `git diff`, podem veure qualsevol d'aquestes diferències en un software com “emerge”, “vimdiff” i altres (incloent productes comercials).
Per saber què tenim disponible al nostre sistema, executem `git difftool --tool-help`.
====

[[_committing_changes]]
==== Committing Your Changes

Now that your staging area is set up the way you want it, you can commit your changes.
Remember that anything that is still unstaged – any files you have created or modified that you haven't run `git add` on since you edited them – won't go into this commit.
They will stay as modified files on your disk.
In this case, let's say that the last time you ran `git status`, you saw that everything was staged, so you're ready to commit your changes.(((git commands, status)))
The simplest way to commit is to type `git commit`:(((git commands, commit)))

[source,console]
----
$ git commit
----

Doing so launches your editor of choice.
(This is set by your shell's `$EDITOR` environment variable – usually vim or emacs, although you can configure it with whatever you want using the `git config --global core.editor` command as you saw in <<_getting_started>>).(((editor, changing default)))(((git commands, config)))

The editor displays the following text (this example is a Vim screen):

[source]
----

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Your branch is up-to-date with 'origin/master'.
#
# Changes to be committed:
#	new file:   README
#	modified:   CONTRIBUTING.md
#
~
~
~
".git/COMMIT_EDITMSG" 9L, 283C
----

You can see that the default commit message contains the latest output of the `git status` command commented out and one empty line on top.
You can remove these comments and type your commit message, or you can leave them there to help you remember what you're committing.
(For an even more explicit reminder of what you've modified, you can pass the `-v` option to `git commit`.
Doing so also puts the diff of your change in the editor so you can see exactly what changes you're committing.)
When you exit the editor, Git creates your commit with that commit message (with the comments and diff stripped out).

Alternatively, you can type your commit message inline with the `commit` command by specifying it after a `-m` flag, like this:

[source,console]
----
$ git commit -m "Story 182: Fix benchmarks for speed"
[master 463dc4f] Story 182: Fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README
----

Now you've created your first commit!
You can see that the commit has given you some output about itself: which branch you committed to (`master`), what SHA-1 checksum the commit has (`463dc4f`), how many files were changed, and statistics about lines added and removed in the commit.

Remember that the commit records the snapshot you set up in your staging area.
Anything you didn't stage is still sitting there modified; you can do another commit to add it to your history.
Every time you perform a commit, you're recording a snapshot of your project that you can revert to or compare to later.

==== Skipping the Staging Area

(((staging area, skipping)))
Although it can be amazingly useful for crafting commits exactly how you want them, the staging area is sometimes a bit more complex than you need in your workflow.
If you want to skip the staging area, Git provides a simple shortcut.
Adding the `-a` option to the `git commit` command makes Git automatically stage every file that is already tracked before doing the commit, letting you skip the `git add` part:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

no changes added to commit (use "git add" and/or "git commit -a")
$ git commit -a -m 'added new benchmarks'
[master 83e38c7] added new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)
----

Notice how you don't have to run `git add` on the `CONTRIBUTING.md` file in this case before you commit.
That's because the `-a` flag includes all changed files.
This is convenient, but be careful; sometimes this flag will cause you to include unwanted changes.

[[_removing_files]]
==== Removing Files

(((files, removing)))
To remove a file from Git, you have to remove it from your tracked files (more accurately, remove it from your staging area) and then commit.
The `git rm` command does that, and also removes the file from your working directory so you don't see it as an untracked file the next time around.

If you simply remove the file from your working directory, it shows up under the ``Changed but not updated'' (that is, _unstaged_) area of your `git status` output:

[source,console]
----
$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        deleted:    PROJECTS.md

no changes added to commit (use "git add" and/or "git commit -a")
----

Then, if you run `git rm`, it stages the file's removal:

[source,console]
----
$ git rm PROJECTS.md
rm 'PROJECTS.md'
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    deleted:    PROJECTS.md
----

The next time you commit, the file will be gone and no longer tracked.
If you modified the file and added it to the index already, you must force the removal with the `-f` option.
This is a safety feature to prevent accidental removal of data that hasn't yet been recorded in a snapshot and that can't be recovered from Git.

Another useful thing you may want to do is to keep the file in your working tree but remove it from your staging area.
In other words, you may want to keep the file on your hard drive but not have Git track it anymore.
This is particularly useful if you forgot to add something to your `.gitignore` file and accidentally staged it, like a large log file or a bunch of `.a` compiled files.
To do this, use the `--cached` option:

[source,console]
----
$ git rm --cached README
----

You can pass files, directories, and file-glob patterns to the `git rm` command.
That means you can do things such as:

[source,console]
----
$ git rm log/\*.log
----

Note the backslash (`\`) in front of the `*`.
This is necessary because Git does its own filename expansion in addition to your shell's filename expansion.
This command removes all files that have the `.log` extension in the `log/` directory.
Or, you can do something like this:

[source,console]
----
$ git rm \*~
----

This command removes all files whose names end with a `~`.

[[_git_mv]]
==== Moving Files

(((files, moving)))
Unlike many other VCS systems, Git doesn't explicitly track file movement.
If you rename a file in Git, no metadata is stored in Git that tells it you renamed the file.
However, Git is pretty smart about figuring that out after the fact – we'll deal with detecting file movement a bit later.

Thus it's a bit confusing that Git has a `mv` command.
If you want to rename a file in Git, you can run something like:

[source,console]
----
$ git mv file_from file_to
----

and it works fine.
In fact, if you run something like this and look at the status, you'll see that Git considers it a renamed file:

[source,console]
----
$ git mv README.md README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README
----

However, this is equivalent to running something like this:

[source,console]
----
$ mv README.md README
$ git rm README.md
$ git add README
----

Git figures out that it's a rename implicitly, so it doesn't matter if you rename a file that way or with the `mv` command.
The only real difference is that `git mv` is one command instead of three – it's a convenience function.
More importantly, you can use any tool you like to rename a file, and address the add/rm later, before you commit.
